package com.wellsfargo.data_structure.heap;

import java.util.PriorityQueue;

/**
 * @author Siddhanta Kumar Pattnaik
 */
public class HuffmanEncoding {

    private HuffmanNode root = null;
    private String[] stringArray;
    private int[] charfreq;
    private PriorityQueue<HuffmanNode> q;

    public HuffmanEncoding(String[] stringArray, int[] charfreq) {
        this.stringArray = stringArray;
        this.charfreq = charfreq;
        this.q = new PriorityQueue<>(stringArray.length);
    }

    public void constructHoffmanTree() {
        for (int i = 0; i < stringArray.length; i++) {
            // creating a huffman node object and adding it to the priority-queue.
            HuffmanNode hn = new HuffmanNode(stringArray[i], charfreq[i]);
            // add functions adds the huffman node to the queue.
            q.add(hn);
        }

        // Here we will extract the two minimum value  from the heap each time until its size reduces to 1, extract until all the nodes are extracted.
        while (q.size() > 1) {

            // first min extract.
            HuffmanNode x = (HuffmanNode)q.peek();
            q.poll();

            // second min extarct.
            HuffmanNode y = (HuffmanNode)q.peek();
            q.poll();

            // new node f which is equal
            HuffmanNode f = new HuffmanNode(x, y, "-", x.frequency + y.frequency);

            // to the sum of the frequency of the two nodes assigning values to the f node. marking the f node as the root node.
            root = f;
            // add this node to the priority-queue.
            q.add(f);
        }

    }

    public void printCode() {
        printCode(root, "");
    }

    private void printCode(HuffmanNode root, String s) {
        // base case; if the left and right are null then its a leaf node and we print the code s generated by traversing the tree.
        if(root==null)
            return ;
        if (root.isLeaf() &&
                !root.character.equals("-")) {
            // c is the character in the node
            System.out.println(root.character + ":" + s);
            return;
        }
        // if we go to left then add "0" to the code. if we go to the right add"1" to the code. recursive calls for left and  right sub-tree of the generated tree.
        printCode(root.left, s + "0");
        printCode(root.right, s + "1");
    }

    static class HuffmanNode implements Comparable<HuffmanNode>,Cloneable {

        HuffmanNode left;
        HuffmanNode right;
        String character;
        int frequency;

        public HuffmanNode(HuffmanNode left, HuffmanNode right, String ch, int freq) {
            this.left = left;
            this.right = right;
            this.character = ch;
            this.frequency = freq;
        }

        public HuffmanNode(String character, int frequency) {
            this.character = character;
            this.frequency = frequency;
        }

        public boolean isLeaf() {
            return left == null && right == null;
        }

        @Override
        public int compareTo(HuffmanNode o) {
            return this.frequency - o.frequency;
        }

        @Override
        public String toString() {
            return "char->"+character+"freq->"+frequency;
        }

        @Override
        protected Object clone()  {
            HuffmanNode huffmanNode =new HuffmanNode(character, frequency);
            if(huffmanNode.left!=null)
                huffmanNode.left= (HuffmanNode)left.clone();
            if(huffmanNode.right!=null)
                huffmanNode.right= (HuffmanNode)right.clone();
            return huffmanNode;
        }
    }


    public static void main(String[] args) {

        int n = 6;
        String[] stringArray = {"a", "b", "c", "d", "e", "f"};
        int[] charfreq = {5, 9, 12, 13, 16, 45};

        HuffmanEncoding huffmanEncoding = new HuffmanEncoding(stringArray, charfreq);
        huffmanEncoding.constructHoffmanTree();
        huffmanEncoding.printCode();
    }
}
